{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © Iron 2018 all right reserved，powered by Gitbook修订时间： 2019-08-28 10:35:36 "},"content/webpack/webpack 模块打包原理.html":{"url":"content/webpack/webpack 模块打包原理.html","title":"webpack 模块打包原理","keywords":"","body":"webpack 模块打包原理 作为一个前端工程师，webpack是日常工作中重要的前端打包工具。出于好奇想了解webpack打包完的代码为什么能在浏览器运营 为什么webpack支持ES6，和CommonJS。在翻阅了一些文章后写下了这篇文章，希望自己温故而知新。也希望帮助到有缘的读者 模块规范 目前本人所认识到的主流的模块规范有以下（自从有了ES6 Module及Webpack等工具，AMD/CMD规范生存空间已经很小了在此不做讨论） CommonJS ES6 UMD CommonJS 在ES6之前，js没有属于自己的模块规范，所以社区制定了CommonJS规范，而nodejs采用的便是CommonJS的规范 // a.js 导出a.js module.exports = { name: 'earsuo', age: 24 } // index.js 导入a.js const perosn = require('./a.js) ES6 ES6模块的设计思想是尽量的静态化，是的编译时就能确定分模块的依赖关系，以及输入输出的变化 // a.js 导出a.js export default { name: 'earsuo', age: 24 } // index.js 导入a.js import person from './a.js' Webpack模块打包 接下来我们就通过最简单的webpack打包出的代码为入口，来分析webpack是如何解析不同的文件的 首先创建一个最简单的webpack打包工程 bar.js文件 // bar.js export default function(name) { return `Hello ${name} ` } index.js文件 // index.js import Bar from './bar.js' Bar('earsuo') webpack.config.js文件 // webpack.config.js const path = require('path') module.exports = { mode: 'development', // JavaScript 执行入口文件 entry: './index.js', output: { // 把所有依赖的模块合并输出到一个 bundle.js 文件 filename: 'bundle.js', // 输出文件都放到 dist 目录下 path: path.resolve(__dirname, './dist'), } }; 打包后的bundle.js（删除部分代码之后的精简代码） // modules是存放所有模块的数组，数组中每个元素存储{ 模块路径: 模块导出代码函数 } (function(modules) { // 缓存模块的作用 var installedModules = {}; // webpack 的require函数 这里很重要 function __webpack_require__(moduleId) { // 判断模块是否已经缓存 if(installedModules[moduleId]) { return installedModules[moduleId].exports; } // 创建一个新的模块，并放入缓存中 var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} }; // 把要加载的模块内容，挂载到module.exports上 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 标记该模块已经加载 module.l = true; // 返回模块 return module.exports; } // __webpack_require__对象下的r函数 // 在module.exports上定义__esModule为true，表明是一个模块对象 __webpack_require__.r = function(exports) { if(typeof Symbol !== 'undefined' && Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }); } Object.defineProperty(exports, '__esModule', { value: true }); }; // 启动入口模块并且返回 exports return __webpack_require__(__webpack_require__.s = \"./index.js\"); }) ({ // bar模块 \"./bar.js\": (function(module, __webpack_exports__, __webpack_require__) { \"use strict\"; eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = (function(name) {\\n return `Hello ${name} `\\n});\\n\\n//# sourceURL=webpack:///./bar.js?\"); }), // 入口模块 \"./index.js\": (function(module, __webpack_exports__, __webpack_require__) { \"use strict\"; eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _bar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bar.js */ \\\"./bar.js\\\");\\n\\nObject(_bar_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"])('earsuo')\\n\\n//# sourceURL=webpack:///./index.js?\"); }) }); 分析打包后的代码 以上是打包完之后的精简代码，打包完成之后得到了一个立即执行函数。而传入的参数就是我们写的各个模块内容的数组（[{ 模块路径: 模块导出代码函数 },{ 模块路径: 模块导出代码函数 }]）。并且webpack控制了模块的module, exports, require。之所以打包完之后的代码可以跑在浏览器中，是因为webpack的webpack_require函数模拟了模块的加载（也就是require），将模块内容挂载到moule.exports上。与此同时webpack_require函数还做了缓存，避免了想通模块的多次加载，优化了性能 整理立即执行函数都做了什么事（该部分借鉴了网友整理的内容） 1 立即执行函数首先定义了一个installedModules，用来缓存已经加载的模块 2 然后定义了webpack_require函数用来模拟require，参数为模块的id 3. webpack_require首先会判断模块是否已经缓存，若已经缓存则直接返回模块内容 4. 如果没有缓存则创建一个新的模块并将模块放入缓存中（及installedModules） 5. 然后将模块内容挂载到module.exports上 6. 标记模块已加载并返回模块的内容 7. 利用webpack_require引入入口模块 第一个模块会根据自己对其他模块的require，依次加载其他模块，最终形成一个依赖网状结构。 Copyright © Iron 2018 all right reserved，powered by Gitbook修订时间： 2019-09-12 17:33:43 "}}