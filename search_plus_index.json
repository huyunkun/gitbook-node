{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © Iron 2018 all right reserved，powered by Gitbook修订时间： 2019-08-28 10:35:36 "},"content/webpack/webpack 模块打包原理.html":{"url":"content/webpack/webpack 模块打包原理.html","title":"webpack 模块打包原理","keywords":"","body":"webpack 模块打包原理 作为一个前端工程师，webpack是日常工作中重要的前端打包工具。出于好奇想了解webpack打包完的代码为什么能在浏览器运营 为什么webpack支持ES6，和CommonJS。在翻阅了一些文章后写下了这篇文章，希望自己温故而知新。也希望帮助到有缘的读者 模块规范 目前本人所认识到的主流的模块规范有以下（自从有了ES6 Module及Webpack等工具，AMD/CMD规范生存空间已经很小了在此不做讨论） CommonJS ES6 UMD CommonJS 在ES6之前，js没有属于自己的模块规范，所以社区制定了CommonJS规范，而nodejs采用的便是CommonJS的规范 // a.js 导出a.js module.exports = { name: 'earsuo', age: 24 } // index.js 导入a.js const perosn = require('./a.js) ES6 ES6模块的设计思想是尽量的静态化，是的编译时就能确定分模块的依赖关系，以及输入输出的变化 // a.js 导出a.js export default { name: 'earsuo', age: 24 } // index.js 导入a.js import person from './a.js' Webpack模块打包 接下来我们就通过最简单的webpack打包出的代码为入口，来分析webpack是如何解析不同的文件的 首先创建一个最简单的webpack打包工程 bar.js文件 // bar.js export default function(name) { return `Hello ${name} ` } index.js文件 // index.js import Bar from './bar.js' Bar('earsuo') webpack.config.js文件 // webpack.config.js const path = require('path') module.exports = { mode: 'development', // JavaScript 执行入口文件 entry: './index.js', output: { // 把所有依赖的模块合并输出到一个 bundle.js 文件 filename: 'bundle.js', // 输出文件都放到 dist 目录下 path: path.resolve(__dirname, './dist'), } }; 打包后的bundle.js（删除部分代码之后的精简代码） // modules是存放所有模块的数组，数组中每个元素存储{ 模块路径: 模块导出代码函数 } (function(modules) { // 缓存模块的作用 var installedModules = {}; // webpack 的require函数 这里很重要 function __webpack_require__(moduleId) { // 判断模块是否已经缓存 if(installedModules[moduleId]) { return installedModules[moduleId].exports; } // 创建一个新的模块，并放入缓存中 var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} }; // 把要加载的模块内容，挂载到module.exports上 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 标记该模块已经加载 module.l = true; // 返回模块 return module.exports; } // __webpack_require__对象下的r函数 // 在module.exports上定义__esModule为true，表明是一个模块对象 __webpack_require__.r = function(exports) { if(typeof Symbol !== 'undefined' && Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }); } Object.defineProperty(exports, '__esModule', { value: true }); }; // 启动入口模块并且返回 exports return __webpack_require__(__webpack_require__.s = \"./index.js\"); }) ({ // bar模块 \"./bar.js\": (function(module, __webpack_exports__, __webpack_require__) { \"use strict\"; eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = (function(name) {\\n return `Hello ${name} `\\n});\\n\\n//# sourceURL=webpack:///./bar.js?\"); }), // 入口模块 \"./index.js\": (function(module, __webpack_exports__, __webpack_require__) { \"use strict\"; eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _bar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bar.js */ \\\"./bar.js\\\");\\n\\nObject(_bar_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"])('earsuo')\\n\\n//# sourceURL=webpack:///./index.js?\"); }) }); 分析打包后的代码 以上是打包完之后的精简代码，打包完成之后得到了一个立即执行函数。而传入的参数就是我们写的各个模块内容的数组（[{ 模块路径: 模块导出代码函数 },{ 模块路径: 模块导出代码函数 }]）。并且webpack控制了模块的module, exports, require。之所以打包完之后的代码可以跑在浏览器中，是因为webpack的webpack_require函数模拟了模块的加载（也就是require），将模块内容挂载到moule.exports上。与此同时webpack_require函数还做了缓存，避免了相同模块的多次加载，优化了性能 整理立即执行函数都做了什么事（该部分借鉴了网友整理的内容） 1 立即执行函数首先定义了一个installedModules，用来缓存已经加载的模块 2 然后定义了webpack_require函数用来模拟require，参数为模块的id 3. webpack_require首先会判断模块是否已经缓存，若已经缓存则直接返回模块内容 4. 如果没有缓存则创建一个新的模块并将模块放入缓存中（及installedModules） 5. 然后将模块内容挂载到module.exports上 6. 标记模块已加载并返回模块的内容 7. 利用webpack_require引入入口模块 第一个模块会根据自己对其他模块的require，依次加载其他模块，最终形成一个依赖网状结构。 Copyright © Iron 2018 all right reserved，powered by Gitbook修订时间： 2019-09-16 13:51:53 "},"content/webpack/webpack 模块异步加载.html":{"url":"content/webpack/webpack 模块异步加载.html","title":"webpack 模块异步加载","keywords":"","body":"webpack 模块异步加载 在日常开发中(本人日常工作开发主要使用vue)我们经常使用import()的方法加载不同路由下的模块,来实现路由懒加载。 这是使用了webpakc中的动态加载模块来实现的。webpakc中动态加载模块有两个方法:import() 和 require.ensure()。 在老版本中使用的是require.ensure()，而在webpack4中使用的import()。接下来就让我们一起以import()为例子来看看webpack的动态加载是如何实现的 webpack模块动态打包 首先来实现一个最简单的webpak动态打包 bar.js export default function() { return 'hello hyk' } index.js function runIndex() { import('./bar.js').then(_ => { console.log('earsuo') }) } webpack.config.js const path = require('path') module.exports = { mode: 'development', entry: path.join(__dirname, 'index.js'), output: { path: path.join(__dirname, 'outs'), filename: 'index.js', chunkFilename: '[name].bundle.js' } } 精简后的webpack打包代码 (function(modules) { // webpackBootstrap // 获取到异步chunk函数后的毁掉函数 // 也是链接异步模块和主模块的重要函数 // 传入的参数data为 [[模块id], {模块路径： 模块函数}}] function webpackJsonpCallback(data) { // data[0]存放了异步模块对应的chunkId var chunkIds = data[0]; // data[1]存放了异步模块代码 var moreModules = data[1]; // 标记所有的异步模块已加载成功 var moduleId, chunkId, i = 0, resolves = []; for(;i {\\n console.log(bar())\\n})\\n\\n__webpack_require__.e(/*! import() */ 1).then(__webpack_require__.bind(null, /*! ./foo.js */ \\\"./foo.js\\\")).then(foo => {\\n console.log(foo())\\n})\\n\\n//# sourceURL=webpack:///./index.js?\"); }) }); 从打包完的代码来看，webpack实现异步加载的方式有点像jsonp，在index.js中通过在head中构建script标签，异步记载模块信息，然后使用webpackJsonpCallback函数，把一步的代码同步到主文件中， 所以后续的操作可以像同步模块一样 接着我们单独分析一下webpack_require.e这个方法 __webpack_require__.e = function requireEnsure(chunkId) { // 创建promise // 将resolve保存在installedChunks[chunkId]中，当代码加载完成之后执行resolve() 返回promise var promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; }); // 通过忘head中添加script标签来动态加载chunk代码 var script = document.createElement('script'); script.charset = 'utf-8'; script.timeout = 120; if (__webpack_require__.nc) { script.setAttribute(\"nonce\", __webpack_require__.nc); } script.src = jsonpScriptSrc(chunkId); onScriptComplete = function (event) { // avoid mem leaks in IE. script.onerror = script.onload = null; clearTimeout(timeout); var chunk = installedChunks[chunkId]; }; script.onerror = script.onload = onScriptComplete; document.head.appendChild(script); return Promise.all(promises); }; 我们可以看到webpack_require.e首先创建了一个promise，并将resolev保存到了installedChunks[chunkId]中。 然后通过往head中动态添加script标签来加载异步模块，并返回promise 接下来我们再来看一下异步模块的代码 0.bundle.js (window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[0],{ \"./bar.js\": (function(module, __webpack_exports__, __webpack_require__) { \"use strict\"; eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = (function() {\\n return 'hello hyk'\\n});\\n\\n//# sourceURL=webpack:///./bar.js?\"); }) }]); 这部分代码最重要的部分在于使用了window[\"webpackJsonp\"]方法。 打包后的主代码中有一句 var jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []; jsonpArray.push = webpackJsonpCallback; 这句代码就表明 window[\"webpackJsonp\"].push 就是 webpackJsonpCallback方法 单独分析webpackJsonpCallback这个函数 function webpackJsonpCallback(data) { // data[0]存放了异步模块对应的chunkId var chunkIds = data[0]; // data[1]存放了异步模块代码 var moreModules = data[1]; // 标记所有的异步模块已加载成功 var moduleId, chunkId, i = 0, resolves = []; for(;i 这个方法的意义在于将异步加载的代码和主模块代码链接起来，并执行异步代码 总结 1. 遇到异步模块时通过webpack_require.e方法将异步代码加载进来，该函数会在head中动态增加script标签，scr会指向制定的异步文件位置 2. 加载的异步文件会执行webpackJsonpCallback函数， 把一步模块加载到主文件中 3. 然后webpack可以像同步模块一样，直接使用webpack_require方法加载异步模块 Copyright © Iron 2018 all right reserved，powered by Gitbook修订时间： 2019-09-16 14:58:39 "}}